#!/usr/bin/python3
# -*- coding: utf-8 -*-

import os
import re
import sys
import json
from glob import glob
from string import Template
from zipfile import ZipFile, ZIP_STORED
from argparse import ArgumentParser, ArgumentTypeError
import html

scriptDir, _ = os.path.split(sys.argv[0])
templateDir = 'opf-templates'

def loadTemplate(templateFile):
    return Template(open(os.path.join(scriptDir, templateDir, templateFile), 'r').read())

templates = {
    'cover' : loadTemplate('template-cover.html'),
    'title' : loadTemplate('template-title-page.html'),
    'toc'   : loadTemplate('template-toc.html'),
    'ncx'   : loadTemplate('template-toc.ncx'),
    'opf'   : loadTemplate('template-content.opf')
}

class Indentor:
    INDENT = '    '
    def __init__(self, level=0):
        self.level = level
    def __enter__(self):
        self.level +=1
        return self
    def __exit__(self, type, value, traceback):
        self.level -= 1
        return False
    def indentation(self, adjust=0):
        return Indentor.INDENT * (self.level + adjust)


class Generator(object):
    def __init__(self, ebookData):
        self.ebook = ebookData
        self.format = None
        self.baseDir = os.path.dirname(self.ebook['filename'])

        self.initEBookContentsLists()

        self.outline = {}
        depth = self.ebook['toc']['depth']
        for item in self.ebook['contents']:
            if not item['type'] in self.ebook['toc']['parse']:
                continue
            fname = item['source']
            self.outline[fname] = Generator.outlineEBookContents(fname, depth)

        images = set()
        for item in self.ebook['contents']:
            if item['generate']:
                continue
            images.update(Generator.collectImagesFromEBookContents(item['source']))
        self.images = sorted(list(images))

    @staticmethod
    def outlineEBookContents(htmlFile, depth):
        results = None
        #with open(htmlFile, encoding='utf-8', mode='r') as f:
        with open(htmlFile, mode='r') as f:
            contents = f.read()
            regex = re.compile('<h(\d+)(?:\s+id=\"(.*)\")?>(.*)</h\d>',
                               re.IGNORECASE|re.MULTILINE|re.UNICODE)
            results = regex.findall(contents)
        if not results:
            return False

        contextStack = [(0, None, None, [])]
        for level, tagId, title in results:
            level = int(level)
            if level > depth:
                continue
            title = re.sub('<\s*br\s*/\s*>', ' ', title)
            title = re.sub('<\s*a\s+.*/\s*a\s*>', '', title)
            item = (level, tagId, title, [])
            while level <= contextStack[-1][0]:
                contextStack.pop()
            contextStack[-1][-1].append(item)
            contextStack.append(item)
        return contextStack[0][-1]

    @staticmethod
    def collectImagesFromEBookContents(htmlFile):
        with open(htmlFile, encoding='utf-8', mode='r') as f:
            contents = f.read()
            regex = re.compile('<img.*\s+src=["\'](.*?)["\']',
                               re.IGNORECASE|re.MULTILINE|re.UNICODE)
            return regex.findall(contents)

    def initEBookContentsLists(self):
        self.tocList = []
        for i in self.ebook['contents']:
            item = i['source']
            if i['type'] in self.ebook['toc']['parse']:
                self.tocList.append(item)

    def saveEBook(self):
        print('Generating %s file for eBook "%s".' % (self.format, self.ebook['title']))
        self.createEBookFile()
        print('%s file "%s" successfully generated.' % (self.format, self.ebook['filename']))

    def createEBookFile(self):
        raise NotImplementedError


class OPFGenerator(Generator):

    EPUB_CONTAINER = '''
<?xml version="1.0"?>
<container version="1.0" xmlns="urn:oasis:names:tc:opendocument:xmlns:container">
    <rootfiles>
        <rootfile full-path="OEBPS/content.opf" media-type="application/oebps-package+xml"/>
    </rootfiles>
</container>
'''.strip()

    def __init__(self, ebookData, ebookFormat):
        Generator.__init__(self, ebookData)
        self.format = ebookFormat

    def generateHtmlCover(self):
        return templates['cover'].substitute(title=html.escape(self.ebook['title'], True),
                                             coverimage=self.ebook['cover'])

    def generateHtmlTitlePage(self):
        return templates['title'].substitute(title=self.ebook['title'],
                                             author=self.ebook['authors'][0]['name'])

    def generateHtmlToCPage(self):
        indentor = Indentor(-1)
        def generateSection(fileName, tocItems):
            tocTxt = ''
            with indentor as ind:
                for level, tagId, title, children in tocItems:
                    url = fileName + '#' + tagId if tagId else fileName
                    tocTxt += '<p style="text-indent: %dem;"><a href="%s">%s</a></p>\n' % \
                              (ind.level, url, title)
                    if children:
                        tocTxt += generateSection(fileName, children)
            return tocTxt

        tocTxt = ''
        for fileName in self.tocList:
            tocTxt += '<div style="margin-top: 1em;">\n'
            tocTxt += generateSection(fileName, self.outline[fileName])
            tocTxt += '</div>\n'

        tocTitle = self.ebook['toc']['generate']['title']
        return templates['toc'].substitute(title=tocTitle, toc=tocTxt)

    def generateNcx(self):
        ncxDict = {
            'title'     : self.ebook['title'],
            'author'    : self.ebook['authors'][0]['name'],
            'bookid'    : 'BookId', #self.ebook['identifier']['id'],
            'depth'     : self.ebook['toc']['depth']
        }
        indentor = Indentor(-1)
        global counter
        counter = 0
        def generateSection(fileName, tocItems):
            global counter
            nav = ''
            with indentor as ind:
                for level, tagId, title, children in tocItems:
                    counter += 1
                    nav += ind.indentation()
                    nav += '<navPoint id="nav{0}" playOrder="{0}">\n'.format(counter)
                    url = fileName + '#' + tagId if tagId else fileName
                    with indentor as ind:
                        nav += ind.indentation()
                        nav += '<navLabel><text>%s</text></navLabel>\n' % title
                        nav += ind.indentation()
                        nav += '<content src="%s"/>\n' % url
                    if children:
                        nav += generateSection(fileName, children)
                    nav += ind.indentation() + '</navPoint>\n'
            return nav

        nav = ''
        for fileName in self.tocList:
            nav += generateSection(fileName, self.outline[fileName])
        ncxDict['navpoints'] = nav
        return templates['ncx'].substitute(ncxDict)

    def generateOpf(self):
        opfDict = {
            'title' : self.ebook['title'],
            'author' : self.ebook['authors'][0]['name'],
            'authorOpfFileAs' : '',
            'rights' : self.ebook['rights'],
            'bookId' : 'bookId',#self.ebook['identifier']['id'],
            'idOpfScheme' : self.ebook['identifier']['scheme'].upper(),
            'idValue' : self.ebook['identifier']['value'],
            'publisher' : self.ebook['publisher'],
            'lang' : self.ebook['language'],
            'coverMetaLine' : '',
            'imagesMetaLine' : '',
            'manifestCoverLine' : '',
            'manifestContents' : '',
            'spineContents' : '',
            'guideSection' : ''
        }

        if 'sort' in self.ebook['authors'][0]:
            opfDict['authorOpfFileAs'] = 'opf:file-as="%s" ' % \
                                         self.ebook['authors'][0]['sort']

        def getImageLine(image, itemId):
            _, ext = os.path.splitext(image)
            mime = ext[1:]
            if mime == 'jpg':
                mime = 'jpeg'
            return '<item id="%s" href="%s" media-type="image/%s"/>\n' % (itemId, image, mime)

        if 'cover' in self.ebook:
            opfDict['coverMetaLine'] = '<meta name="cover" content="coverimage" />'
            opfDict['manifestCoverLine'] = getImageLine(self.ebook['cover'], 'coverimage')

        for i, image in enumerate(self.images):
            opfDict['imagesMetaLine'] += Indentor.INDENT + getImageLine(image, 'image%d' % i)

        for i, item in enumerate(self.ebook['contents']):
            fileName = item['source']
            opfDict['manifestContents'] += \
                    '%s<item id="item%d" media-type="application/xhtml+xml" href="%s"/>\n' % \
                    (Indentor.INDENT, i, item['source'])
            opfDict['spineContents'] += '%s<itemref idref="item%d"/>\n' % (Indentor.INDENT, i)

        if 'guide' in self.ebook:
            opfDict['guideSection'] = '<guide>\n'
            for ref in self.ebook['guide']:
                opfDict['guideSection'] += Template(Indentor.INDENT + \
                    '<reference type="$type" title="$title" href="$href"/>\n' \
                ).substitute(ref)
            opfDict['guideSection'] += '</guide>\n'

        return templates['opf'].substitute(opfDict)

    def createEBookFile(self):
        ebookFile = '%s.%s' % \
            (os.path.join(self.baseDir, self.ebook['filename']),
             self.format.lower())
        epubFile = ZipFile(ebookFile, 'w')

        # Write mimetype file.
        epubFile.writestr('mimetype', 'application/epub+zip', ZIP_STORED)

        # Write META-INF directory and contents.
        epubFile.writestr(os.path.join('META-INF', 'container.xml'),
                          OPFGenerator.EPUB_CONTAINER, ZIP_STORED)

        # Add book cover image.
        if 'cover' in self.ebook:
            coverFile = os.path.join('OEBPS', self.ebook['cover'])
            epubFile.write(self.ebook['cover'], coverFile)

        # Add images.
        for image in self.images:
            imageFile = os.path.join('OEBPS', image)
            epubFile.write(image, imageFile)

        # Add style sheet file.
        style = os.path.join('OEBPS', 'style.css')
        epubFile.write('style.css', style, ZIP_STORED)

        # Add content files.
        for item in self.ebook['contents']:
            fileName = item['source']

            if not item['generate']:
                dstFile = os.path.join('OEBPS', fileName)
                epubFile.write(fileName, dstFile, ZIP_STORED)
                continue

            if item['type'] == 'cover' and self.format == 'epub':
                dstFilename = os.path.join('OEBPS', fileName)
                dstContents = self.generateHtmlCover()
            elif item['type'] == 'toc':
                dstFilename = os.path.join('OEBPS', fileName)
                dstContents = self.generateHtmlToCPage()
            elif item['type'] == 'title-page':
                dstFilename = os.path.join('OEBPS', fileName)
                dstContents = self.generateHtmlTitlePage()
            else:
                continue
            epubFile.writestr(dstFilename, dstContents, ZIP_STORED)

        # Write OPF file.
        opfFile = os.path.join('OEBPS', 'content.opf')
        epubFile.writestr(opfFile, self.generateOpf(), ZIP_STORED)

        # Write NCX index.
        ncxFile = os.path.join('OEBPS', 'toc.ncx')
        epubFile.writestr(ncxFile, self.generateNcx(), ZIP_STORED)

        epubFile.close()


def parseEBookFile(ebookFile):
    try:
        data = json.load(open(ebookFile, 'r'))
        hasCoverPage = False
        for item in data['contents']:
            # Set generate flag for content item.
            if not 'generate' in item:
                if item['type'] == 'toc' and 'generate' in data['toc']:
                    item['generate'] = True
                else:
                    item['generate'] = False

            # Expand wild cards.
            if item['type'] == 'text' and '*' in item['source']:
                files = sorted(glob(item['source']))
                if not files:
                    raise ArgumentTypeError('\nCan\'t find files from expression: %r' % \
                                            item['source'])
                idx = data['contents'].index(item)
                for f in files:
                    newItem = {
                        'type' : item['type'],
                        'source' : f,
                        'generate' : False
                    }
                    data['contents'].insert(idx, newItem)
                    idx += 1
                del data['contents'][idx]

            if item['type'] == 'cover':
                hasCoverPage = True

        if not hasCoverPage and 'cover' in data:
            coverItem = {
                'type' : 'cover',
                'source' : 'cover.html',
                'generate' : True
            }
            data['contents'].insert(0, coverItem)

    except IOError as e:
        raise ArgumentTypeError('\n%s' % e)
    except ValueError as e:
        raise ArgumentTypeError('\n[JSON parser] %s' % e)
    return data

def main():
    parser = ArgumentParser(description='Generates ebooks from a description file.')
    parser.add_argument('-f', '--format', type=str, default='epub',
                        choices=['epub', 'mobi'],
                        help='Format of the output (default: epub).')
    parser.add_argument('-o', '--output', type=str,
                        help='Name of the output file.')
    parser.add_argument('ebookData', type=parseEBookFile,
                        help='JSON file containing the ebook information.')

    args = vars(parser.parse_args())

    gen = OPFGenerator(args['ebookData'], args['format'])
    gen.saveEBook()

if __name__ == '__main__':
    main()
